%{
	#include "hw3_output.hpp"
	#include "Structures.hpp"
	#include "Symbol.hpp"
	#include "ScopeManager.hpp"
	#include "cg.hpp"
	ScopeManager& scopeManager = ScopeManager::getInstance();
	CodeGenerator& codeGenerator = CodeGenerator::getInstance();
	CodeBuffer& codeBuffer = CodeBuffer::instance();
	int curr_index=0;
	// vector<bool> hasBreak;
	// vector<string> next_label;
	// string next_label2;
	int string_counter=0;
	extern int yylex();
	extern int yylineno;
	// vector<string> labels;
	// vector<vector<pair<int, BranchLabelIndex>>> br_trueLabel_Lists;
	// vector<vector<pair<int, BranchLabelIndex>>> global_break;
	void yyerror(const char *message);
%}

%token 		VOID
%token 		INT
%token		BYTE
%token		B
%token		BOOL
%token		CONST
%token		TRUE
%token		FALSE
%token		RETURN
%nonassoc 	temp
%nonassoc 	ELSE
%nonassoc	IF
%token		WHILE
%token		BREAK
%token		CONTINUE
%token		COLON
%token		SC
%token		COMMA
%token		COMMENT
%token		ID
%token		NUM
%token		STRING
%token		LBRACE
%token		RBRACE

%left   	OR
%left		AND
%right		ASSIGN
%left 		EQUALITY
%nonassoc	NONASSOCCRELOP
%left  		ADD SUB
%left 		MUL DIV
%right		NOT
%left		LPAREN RPAREN
%nonassoc 	tempp


%%
Program : Statements;

Statements : Statement | Statements Statement;

Statement : LBRACE
	{
		scopeManager.pushScope(ScopeType::BLOCK);
	}
	Statements RBRACE FINISH

	| Type ID SC
	{
		if(scopeManager.findSymbolInCurrentScope($2->getName()) == -1) // find if ID was decalred in the current scope
		{
			output::errorDef(yylineno, $2->getName());
            exit(0);
		}
		int variableOffset = scopeManager.getOffset();
		shared_ptr<Symbol> newSymbol = make_shared<Symbol>($2->getName(), $1->getType(), "NO VARIABLE", variableOffset);
		scopeManager.insertSymbol(newSymbol);

		string varOffset = codeGenerator.intToString(variableOffset);
		string varReg = codeGenerator.freshRegister();
		string allocCode = varReg + " = getelementptr [50 x i32], [50 x i32]* %stack_ptr, i32 0, i32 " + varOffset;
		string storeValCode = "store i32 0, i32* " + varReg;
		codeBuffer.emit(allocCode);
		codeBuffer.emit(storeValCode);
	}

	| Type ID ASSIGN Exp SC
	{
		bool expInt = $4->getType() == "INT";
		bool expByte = $4->getType() == "BYTE";
		bool idInt = $1->getType() == "INT";

		if($1->getType() == "BYTE" and $4->getValue() > 255)
		{ // check if the variable was declared as Byte but the value is bigger than what byte holds
			output::errorByteTooLarge(yylineno,to_string($5->getValue()));
			exit(0);
		}
		else if($4->getType() != $1->getType() and (!(expByte && idInt)))
		{ // check if the variable type doesn't match the value given, but it's not int that holds a byte!
			output::errorMismatch(yylineno);
			exit(0);
		}
		else if(scopeManager.findSymbolInCurrentScope($2->getName()) != -1)
		{
			output::errorDef(yylineno, $2->getType());
            exit(0);
		}

		// if we get here all is ok!, add the variable to the symbol table
		int variableOffset = scopeManager.getOffset();
		shared_ptr<Symbol> newSymbol = make_shared<Symbol>($2->getName(), $1->getType(), "NO VARIABLE",variableOffset);
		scopeManager.insertSymbol(newSymbol);
		string varOffset = codeGenerator.intToString(variableOffset);
		if($4->getType() == "BOOL")
		{
			string NextLabel = codeGenerator.freshLabel();
			string newValue1 = getNewRegister();
			string newVariable1 = getNewRegister();
			string newValue2 = getNewRegister();
			string newVariable2 = getNewRegister();
			codeBuffer.emit($4.true_label + ":");
			codeBuffer.emit(newVariable1 + " = getelementptr [50 x i32], [50 x i32]* %stack_ptr, i32 0, i32 " + varOffset);
			codeBuffer.emit(newValue1 + " = zext i1 1 to i32");
			codeBuffer.emit("store i32 " + newValue1 + ", i32* " + newVariable1);
			codeBuffer.emit("br label %" + NextLabel);
			codeBuffer.emit($4.false_label + ":");
			codeBuffer.emit(newVariable2 + " = getelementptr [50 x i32], [50 x i32]* %stack_ptr, i32 0, i32 " + varOffset);
			codeBuffer.emit(newValue2 + " = zext i1 0 to i32");
			codeBuffer.emit("store i32 " + newValue2 + ", i32* " + newVariable2);
			codeBuffer.emit("br label %" + NextLabel);
			codeBuffer.emit(NextLabel + ":");
		}
		else if($4->getType() == "BYTE")
		{
			string newVariable = codeGenerator.freshRegister();
			codeBuffer.emit(newVariable + " = getelementptr [50 x i32], [50 x i32]* %stack_ptr, i32 0, i32 " + varOffset);
			string newVariable2 = codeGenerator.freshRegister();
			codeBuffer.emit(newVariable2 + " = zext i8 " + $4->getVariable() + " to i32");
			codeBuffer.emit("store i32 " + newVariable2 + ", i32* " + newVariable);
		}
		else
		{
			string newVariable = codeGenerator.freshRegister();
			string code1 = newVariable + " = getelementptr [50 x i32], [50 x i32]* %stack_ptr, i32 0, i32 " + varOffset;
			string code2 = "store i32 " + $4->getVariable() + ", i32* " + newVariable;
			codeBuffer.emit(code1);
			codeBuffer.emit(code2);
		}
	}

	| ID ASSIGN Exp SC
	{
		bool foundSymbol = scopeManager.findSymbol($1->getName()); //TODO: get the Symbol itself!
		if(!foundSymbol) { // what if symbol is Func ?
			output::errorUndef(yylineno, $1->getName());
			exit(0);
		}
		// now check if we are assining the right type to the variable!
		shared_ptr<Symbol> variable = scopeManager.getSymbol($1->getName());
		if(variable->getType() == "FUNCTION")
		{
			output::errorUndef(yylineno, variable->getName());
			exit(0);
		}
		string variableType = variable->getType(); // type of variable;
		bool expInt = $3->getType() == "INT";
		bool expByte = $3->getType() == "BYTE" ;
		bool expBool = $3->getType() == "BOOL";
		bool idInt = $1->getType() == "INT";

		if($3->getType() != variableType and !(idInt and expByte)){
			output::errorMismatch(yylineno);
			exit(0);
		}
		string varOffset = codeGenerator.intToString(variable->getOffset());
		if($3->getType() == "BOOL")
		{
			string NextLabel = codeGenerator.freshLabel();
			string newValue1 = getNewRegister();
			string newVariable1 = getNewRegister();
			string newValue2 = getNewRegister();
			string newVariable2 = getNewRegister();
			codeBuffer.emit($3.true_label + ":");
			codeBuffer.emit(newVariable1 + " = getelementptr [50 x i32], [50 x i32]* %stack_ptr, i32 0, i32 " + varOffset);
			codeBuffer.emit(newValue1 + " = zext i1 1 to i32");
			codeBuffer.emit("store i32 " + newValue1 + ", i32* " + newVariable1);
			codeBuffer.emit("br label %" + NextLabel);
			codeBuffer.emit($3.false_label + ":");
			codeBuffer.emit(newVariable2 + " = getelementptr [50 x i32], [50 x i32]* %stack_ptr, i32 0, i32 " + varOffset);
			codeBuffer.emit(newValue2 + " = zext i1 0 to i32");
			codeBuffer.emit("store i32 " + newValue2 + ", i32* " + newVariable2);
			codeBuffer.emit("br label %" + NextLabel);
			codeBuffer.emit(NextLabel + ":");
		}
		else if($3->getType() == "BYTE")
		{
			string newVariable = codeGenerator.freshRegister();
			codeBuffer.emit(newVariable + " = getelementptr [50 x i32], [50 x i32]* %stack_ptr, i32 0, i32 " + varOffset);
			string newVariable2 = codeGenerator.freshRegister();
			codeBuffer.emit(newVariable2 + " = zext i8 " + $3->getVariable() + " to i32");
			codeBuffer.emit("store i32 " + newVariable2 + ", i32* " + newVariable);
		}
		else
		{
			string newVariable = codeGenerator.freshRegister();
			string code1 = newVariable + " = getelementptr [50 x i32], [50 x i32]* %stack_ptr, i32 0, i32 " + varOffset;
			string code2 = "store i32 " + $3->getVariable() + ", i32* " + newVariable;
			codeBuffer.emit(code1);
			codeBuffer.emit(code2);
		}

	}

	| Call SC {}
	| RETURN SC { codeBuffer.emit("ret i32 0"); };

	FINISH:
	{
		scopeManager.popScope();
	};

A:
{
	string branch_cmd_exp1 = "br i1 " + $0->getVariable() + ", label @, label @";
	int br_exp1_address = codeBuffer.emit(branch_cmd_exp1);
	auto exp_1_newTrueList = codeBuffer.makelist(pair<int, BranchLabelIndex>(br_exp1_address, FIRST));
	auto exp_1_newFalseList = codeBuffer.makelist(pair<int, BranchLabelIndex>(br_exp1_address, SECOND));
	string true_label = codeBuffer.genLabel();
	int br_trueLabel_address = codeBuffer.emit("br label @");
	auto br_tr = codeBuffer.makelist(pair<int, BranchLabelIndex>(br_trueLabel_address, FIRST));
	br_trueLabel_Lists.push_back(br_tr);
	string next_label_val = codeBuffer.genLabel();
	next_label.push_back(next_label_val);
	codeBuffer.bpatch(exp_1_newTrueList, next_label[next_label.size() - 1]);
	codeBuffer.bpatch(exp_1_newFalseList, true_label);
};

T:
{
	string branch_str = "br label @";
	int br_exp1_address = codeBuffer.emit(branch_str);
	auto exp_1_newTrueList = codeBuffer.makelist(pair<int, BranchLabelIndex>(br_exp1_address, FIRST));
	next_label2 = codeBuffer.genLabel();
	auto br_list = br_trueLabel_Lists[br_trueLabel_Lists.size() - 1];
	codeBuffer.bpatch(br_list, next_label2);
	// codeBuffer.bpatch(exp_1_newTrueList, next_label2);
	br_trueLabel_Lists.pop_back();
	br_trueLabel_Lists.push_back(exp_1_newTrueList);
	labels.push_back(next_label2);
};

Y:
	{
		auto adress_val = codeBuffer.emit("br label @");
		auto br_list = br_trueLabel_Lists[br_trueLabel_Lists.size() - 1];
		next_label2 = codeBuffer.genLabel();
		auto exp_1_newTrueList1 = codeBuffer.makelist(pair<int, BranchLabelIndex>(adress_val, FIRST));
		codeBuffer.bpatch(exp_1_newTrueList1, next_label2);
		labels.pop_back();
		codeBuffer.bpatch(br_list, next_label2);
		br_trueLabel_Lists.pop_back();
	};

M:
	{
		if ($-2->getType().compare("BOOL"))
		{
			output::errorMismatch(yylineno);
			exit(0);
		}
		Scope new_scope(offsets.back(), "IF");
		scopes.push_back(new_scope);
		offsets.push_back(offsets.back());
	};

K:
	{
		Scope new_scope(offsets.back(), "ELSE");
		scopes.push_back(new_scope);
		offsets.push_back(offsets.back());
	};

N:
	{
		int br_trueLabel_address1 = codeBuffer.emit("br label @");
		auto exp_1_newTrueList1 = codeBuffer.makelist(pair<int, BranchLabelIndex>(br_trueLabel_address1, FIRST));
		string next_label_val = codeBuffer.genLabel();
		next_label.push_back(next_label_val);
		codeBuffer.bpatch(exp_1_newTrueList1, next_label[next_label.size() - 1]);
	};

Call: ID LPAREN Exp RPAREN
	{

	};

Type: INT  { $$ = new Symbol("INT", "INT");   }
	| BYTE { $$ = new Symbol("BYTE", "BYTE"); }
	| BOOL { $$ = new Symbol("BOOL", "BOOL"); };

Exp: LPAREN Exp RPAREN
	{
		$$ = $2;
	}

	| Exp MUL Exp
	{
		bool exp1IsNumericType = $1->getType() == "INT" or $1->getType() == "BYTE";
		bool exp2IsNumericType = $3->getType() == "INT" or $3->getType() == "BYTE";
		if (!exp1IsNumericType or !exp2IsNumericType)
		{
			output::errorMismatch(yylineno);
			exit(0);
		}
		string resultType;
		if ($1->getType() == "INT" || $3->getType() == "INT")
			resultType = "INT";
		else
			resultType = "BYTE";
		$$ = new Symbol(resultType, resultType);

		string resultRegister = codeGenerator.freshRegister();
		string storeCode = resultRegister + " = mul i32 " + $1->getVariable() + "," + $3->getVariable();
		codeBuffer.emit(storeCode);
		if (resultType == "BYTE")
		{
			string truncValue = codeGenerator.freshRegister();
			string truncValueCode = truncValue + " = trunc i32 " + resultRegister + " to i8";
			codeBuffer.emit(truncValueCode);
			string zextValue = codeGenerator.freshRegister();
			string zextValueCode = zextValue + " = zext i8 " + truncValue + " to i32";
			codeBuffer.emit(zextValueCode);
			$$->setVariable(zextValue);
		}
		else
			$$->setVariable(resultRegister);
	}

	| Exp DIV Exp
	{
		bool exp1IsNumericType = $1->getType() == "INT" or $1->getType() == "BYTE";
		bool exp2IsNumericType = $3->getType() == "INT" or $3->getType() == "BYTE";
		if (!exp1IsNumericType || !exp2IsNumericType)
		{
			output::errorMismatch(yylineno);
			exit(0);
		}
		bool operandsAreInts = $1->getType() == "INT" or $3->getType() == "INT";
		string resultType =  operandsAreInts ? "INT" : "BYTE";
		$$ = new Symbol(resultType, resultType);

		string resultRegister = codeGenerator.freshRegister();
		string divisionLabel = CodeBuffer::instance().freshLabel();
		string comapreCode = resultRegister + " = icmp eq i8 0, " + $3->getVariable();
		string branchCode = "br i1 " + resultRegister + ", label %ERROR_LABEL, label %" + divisionLabel;
		CodeBuffer::instance().emit(comapreCode);
		CodeBuffer::instance().emit(branchCode);
		CodeBuffer::instance().emit(divisionLabel + ":");
		resultRegister = codeGenerator.freshRegister();
		CodeBuffer::instance().emit(resultRegister + " = udiv i8 " + $1->getVariable() + ", " + $3->getVariable());

		//continunte here if not error
		string resultValue = codeGenerator.freshRegister();
		string resultValueCode;
		if (resultType == "BYTE")
			resultValueCode = resultValue + " = udiv i32 " + $1->getVariable() + "," + $3->getVariable();
		else
			resultValueCode = resultValue + " = sdiv i32 " + $1->getVariable() + "," + $3->getVariable();
		codeBuffer.emit(resultValueCode);
		$$->setVariable(resultValue);
	}

	| Exp ADD Exp
	{
		bool exp1IsNumericType = $1->getType() == "INT" or $1->getType() == "BYTE";
		bool exp2IsNumericType = $3->getType() == "INT" or $3->getType() == "BYTE";
		if (!exp1IsNumericType || !exp2IsNumericType)
		{
			output::errorMismatch(yylineno);
			exit(0);
		}
		bool operandsAreInts = $1->getType() == "INT" or $3->getType() == "INT";
		string resultType =  operandsAreInts ? "INT" : "BYTE";
		$$ = new Symbol(resultType, resultType);

		string resultRegister = codeGenerator.freshRegister();
		string addCommandCode = resultRegister + " = add i32 " + $1->getVariable() + "," + $3->getVariable();
		codeBuffer.emit(addCommandCode);
		if (resultType == "BYTE")
		{
			string truncValue = codeGenerator.freshRegister();
			string truncCommandCode = truncValue + " = trunc i32 " + resultRegister + " to i8";
			codeBuffer.emit(truncCommandCode);
			string zextValue = codeGenerator.freshRegister();
			string zextCommandCode = zextValue + " = zext i8 " + truncValue + " to i32";
			codeBuffer.emit(zextCommandCode);
			$$->setVariable(zextValue);
		}
		else
			$$->setVariable(resultRegister);
	}

	| Exp SUB Exp
	{
		bool exp1IsNumericType = $1->getType() == "INT" or $1->getType() == "BYTE";
		bool exp2IsNumericType = $3->getType() == "INT" or $3->getType() == "BYTE";
		if (!exp1IsNumericType || !exp2IsNumericType)
		{
			output::errorMismatch(yylineno);
			exit(0);
		}
		bool operandsAreInts = $1->getType() == "INT" or $3->getType() == "INT";
		string resultType =  operandsAreInts ? "INT" : "BYTE";
		$$ = new Symbol(resultType, resultType);

		string resultRegister = codeGenerator.freshRegister();
		string addCommandCode = resultRegister + " = sub i32 " + $1->getVariable() + "," + $3->getVariable();
		codeBuffer.emit(addCommandCode);
		if (resultType == "BYTE")
		{
			string truncValue = codeGenerator.freshRegister();
			string truncCommandCode = truncValue + " = trunc i32 " + resultRegister + " to i8";
			codeBuffer.emit(truncCommandCode);
			string zextValue = codeGenerator.freshRegister();
			string zextCommandCode = zextValue + " = zext i8 " + truncValue + " to i32";
			codeBuffer.emit(zextCommandCode);
			$$->setVariable(zextValue);
		}
		else
			$$->setVariable(resultRegister);
	}

	| ID
	{
		bool exists = scopeManager.findSymbol($1->getName());
		if(!exists)
		{
			output::errorUndef(yylineno, $1->getName());
			exit(0);
		}
		shared_ptr<Symbol> res = scopeManager.getSymbol($1->getName()); // TODO: check if function!
		string typeOfId = res->getType();
		string varOffset = to_string(res->getOffset());
		$$ = new Symbol(typeOfId, $1->getType());
		$$->setName($1->getType());

		string newVariable = codeGenerator.freshRegister();
		string loadValueCode = newVariable + " = load i32, i32* " + varOffset;
		codeBuffer.emit(loadValueCode);
		if (typeOfId == "BOOL")
		{
			string truncValue = codeGenerator.freshRegister();
			string truncCommandCode = truncValue + " = trunc i32 " + newVariable + " to i1";
			codeBuffer.emit(truncCommandCode);
			$$->setVariable(truncValue);
		}
		else
			$$->setVariable(newVariable);
	}

	| Call {
		$$ = $1;
	}

	| NUM {
		$$ = new Symbol("INT",std::to_string($1->getValue()));
		string variable = codeGenerator.freshRegister();
		string code = variable + "= add i32 " + std::to_string($1->getValue()) + ",0";
		codeBuffer.emit(code);
		$$->setVariable(variable);
	}

	| NUM B
	{
		int value = $1->getValue();
		if (value > 255)
		{
			output::errorByteTooLarge(yylineno, std::to_string(value));
			exit(0);
		}
		string stringValue = std::to_string(value);
		$$ = new Symbol("BYTE", std::to_string($1->getValue()));
		string variable = codeGenerator.freshRegister();
		string code = variable + "= add i32 " + std::to_string($1->getValue()) + ",0";
		codeBuffer.emit(code);
		$$->setVariable(variable);
	}

	| STRING {
		string text = "Baraa"; // $1->getValue();
		text = text.substr(1, text.size() - 2); // removing the " from start and end
		string typeOfString = "[" + std::to_string(text.size() + 1) + " x i8]";
		string nameOfString = "@.STRING_" + std::to_string(string_counter) + "_str";
		codeBuffer.emitGlobal(nameOfString + " = internal constant" + typeOfString + " c\"" + text + "\\00\"");
		string_counter++;
		string var = codeGenerator.freshRegister();
		string command = var + " = getelementptr " + typeOfString + ", " + typeOfString + "* " + nameOfString + ", i32 0, i32 0";
		codeBuffer.emit(command);
		$$ = new Symbol("STRING", $1->getType());
		$$->setVariable(var);
	}

	| TRUE {
		$$ = $1;
		string var = codeGenerator.freshRegister();
		string code = var + " = add i1 1,0";
		codeBuffer.emit(code);
		$$->setVariable(var);
	}

	| FALSE {
		$$ = $1;
		string var = codeGenerator.freshRegister();
		string s = var + " = add i1 0,0";
		codeBuffer.emit(s);
		$$->setVariable(var);
	}

	| NOT Exp
	{
		if ($2->getType() != "BOOL")
		{
			output::errorMismatch(yylineno);
			exit(0);
		}
		$$ = $2;

		// backaptching TODO: remove!
		/* string branch_cmd_exp1 = "br i1 " + $2->getVariable() + ", label @, label @";
		int br_exp1_address = codeBuffer.emit(branch_cmd_exp1);
		auto exp_1_newTrueList = codeBuffer.makelist(pair<int, BranchLabelIndex>(br_exp1_address, FIRST));
		auto exp_1_newFalseList = codeBuffer.makelist(pair<int, BranchLabelIndex>(br_exp1_address, SECOND));

		string true_label = codeBuffer.genLabel();
		int br_trueLabel_address = codeBuffer.emit("br label @");
		auto br_trueLabel_List = codeBuffer.makelist(pair<int, BranchLabelIndex>(br_trueLabel_address, FIRST));
		string false_label = codeBuffer.genLabel();
		int br_falseLabel_address = codeBuffer.emit("br label @");
		auto br_falseLabel_List = codeBuffer.makelist(pair<int, BranchLabelIndex>(br_falseLabel_address, FIRST));
		string finalResultLabel = codeBuffer.genLabel();
		string finalResultVar = codeBuffer.newTemp();
		string phi_cmd = finalResultVar + " = phi i1 [0, %" + false_label + "], [1, %" + true_label + "]";
		codeBuffer.emit(phi_cmd);
		codeBuffer.bpatch(exp_1_newTrueList, false_label);
		codeBuffer.bpatch(exp_1_newFalseList, true_label);
		codeBuffer.bpatch(br_trueLabel_List, finalResultLabel);
		codeBuffer.bpatch(br_falseLabel_List, finalResultLabel);
		$$->setVariable(finalResultVar); */
	}

	| Exp AND
	{
		// backaptching TODO: remove!
		/* string branch_cmd_exp1 = "br i1 " + $1->getVariable() + ", label @, label @";
		int br_exp1_address = codeBuffer.emit(branch_cmd_exp1);
		auto exp_1_newTrueList = codeBuffer.makelist(pair<int, BranchLabelIndex>(br_exp1_address, FIRST));
		auto exp_1_newFalseList = codeBuffer.makelist(pair<int, BranchLabelIndex>(br_exp1_address, SECOND));
		$1->trueList = codeBuffer.merge(exp_1_newTrueList, $1->trueList);
		$1->falseList = codeBuffer.merge(exp_1_newFalseList, $1->falseList);
		string exp1_true_label = codeBuffer.genLabel();
		codeBuffer.bpatch($1->trueList, exp1_true_label); */
	}
	Exp
	{
		if($1->getType() != "BOOL" || $4->getType() != "BOOL" )
		{
			output::errorMismatch(yylineno);
			exit(0);
		}
		$$ = $1;

		// backaptching TODO: remove!
		/* string branch_cmd_exp2 = "br i1 " + $4->getVariable() + ", label @, label @";
		int br_exp2_address = codeBuffer.emit(branch_cmd_exp2);
		auto exp_2_newTrueList = codeBuffer.makelist(pair<int, BranchLabelIndex>(br_exp2_address, FIRST));
		auto exp_2_newFalseList = codeBuffer.makelist(pair<int, BranchLabelIndex>(br_exp2_address, SECOND));
		$4->trueList = codeBuffer.merge(exp_2_newTrueList, $4->trueList);
		$4->falseList = codeBuffer.merge(exp_2_newFalseList, $4->falseList);
		string true_label = codeBuffer.genLabel();
		int br_trueLabel_address = codeBuffer.emit("br label @");
		auto br_trueLabel_List = codeBuffer.makelist(pair<int, BranchLabelIndex>(br_trueLabel_address, FIRST));
		string false_label = codeBuffer.genLabel();
		int br_falseLabel_address = codeBuffer.emit("br label @");
		auto br_falseLabel_List = codeBuffer.makelist(pair<int, BranchLabelIndex>(br_falseLabel_address, FIRST));
		string finalResultLabel = codeBuffer.genLabel();
		string finalResultVar = codeBuffer.newTemp();
		string phi_cmd = finalResultVar + " = phi i1 [0, %" + false_label + "], [1, %" + true_label + "]";
		codeBuffer.emit(phi_cmd);
		codeBuffer.bpatch($1->falseList, false_label);
		codeBuffer.bpatch($4->trueList, true_label);
		codeBuffer.bpatch($4->falseList, false_label);
		codeBuffer.bpatch(br_trueLabel_List, finalResultLabel);
		codeBuffer.bpatch(br_falseLabel_List, finalResultLabel);
		$$->setVariable(finalResultVar); */
	}

	| Exp OR
	{
		// backaptching TODO: remove!
		/* string branch_cmd_exp1 = "br i1 " + $1->getVariable() + ", label @, label @";
		int br_exp1_address = codeBuffer.emit(branch_cmd_exp1);
		auto exp_1_newTrueList = codeBuffer.makelist(pair<int, BranchLabelIndex>(br_exp1_address, FIRST));
		auto exp_1_newFalseList = codeBuffer.makelist(pair<int, BranchLabelIndex>(br_exp1_address, SECOND));
		$1->trueList = codeBuffer.merge(exp_1_newTrueList, $1->trueList);
		$1->falseList = codeBuffer.merge(exp_1_newFalseList, $1->falseList);
		string exp1_false_label = codeBuffer.genLabel();
		codeBuffer.bpatch($1->falseList, exp1_false_label); */
	}
	Exp
	{
		if ($1->getType() != "BOOL" || $4->getType() != "BOOL" )
		{
			output::errorMismatch(yylineno);
			exit(0);
		}
		$$ = $1;

		// backaptching TODO: remove!
		/* string branch_cmd_exp2 = "br i1 " + $4->getVariable() + ", label @, label @";
		int br_exp2_address = codeBuffer.emit(branch_cmd_exp2);
		auto exp_2_newTrueList = codeBuffer.makelist(pair<int, BranchLabelIndex>(br_exp2_address, FIRST));
		auto exp_2_newFalseList = codeBuffer.makelist(pair<int, BranchLabelIndex>(br_exp2_address, SECOND));
		$4->trueList = codeBuffer.merge(exp_2_newTrueList, $4->trueList);
		$4->falseList = codeBuffer.merge(exp_2_newFalseList, $4->falseList);
		string false_label = codeBuffer.genLabel();
		int br_falseLabel_address = codeBuffer.emit("br label @");
		auto br_falseLabel_List = codeBuffer.makelist(pair<int, BranchLabelIndex>(br_falseLabel_address, FIRST));
		string true_label = codeBuffer.genLabel();
		int br_trueLabel_address = codeBuffer.emit("br label @");
		auto br_trueLabel_List = codeBuffer.makelist(pair<int, BranchLabelIndex>(br_trueLabel_address, FIRST));
		string finalResultLabel = codeBuffer.genLabel();
		string finalResultVar = codeBuffer.newTemp();
		string phi_cmd = finalResultVar + " = phi i1 [0, %" + false_label + "], [1, %" + true_label + "]";
		codeBuffer.emit(phi_cmd);
		codeBuffer.bpatch($1->trueList, true_label);
		codeBuffer.bpatch($4->trueList, true_label);
		codeBuffer.bpatch($4->falseList, false_label);
		codeBuffer.bpatch(br_trueLabel_List, finalResultLabel);
		codeBuffer.bpatch(br_falseLabel_List, finalResultLabel);
		$$->setVariable(finalResultVar); */
	}

	| Exp NONASSOCCRELOP Exp
	{
		bool exp1IsNumericType = $1->getType() == "INT" or $1->getType() == "BYTE";
		bool exp2IsNumericType = $3->getType() == "INT" or $3->getType() == "BYTE";
		if (!exp1IsNumericType or !exp2IsNumericType)
		{
			output::errorMismatch(yylineno);
			exit(0);
		}
		$$ = new Symbol("BOOL", "BOOL");

		bool isSigned = ($1->getType() == "INT" or $3->getType() == "INT");
		string equalOperator = isSigned ?  "sgt" :"ugt";
		if ($2->getType() == ">=")
			equalOperator = isSigned ?  "sge" : "uge";
		else if ($2->getType() == "<")
			equalOperator = isSigned ?  "slt" : "ult";
		else if (!$2->getType().compare("<="))
			equalOperator = isSigned ?  "sle" : "ule";


		string newVar = codeGenerator.freshRegister();
		string cmpCommand;
		cmpCommand = newVar + " = icmp " + equalOperator + " i32 " + $1->getVariable() + ", " + $3->getVariable();
		$$->setVariable(newVar);
		codeBuffer.emit(cmpCommand);
	}

	| Exp EQUALITY Exp
	{
		bool exp1IsNumericType = $1->getType() == "INT" or $1->getType() == "BYTE";
		bool exp2IsNumericType = $3->getType() == "INT" or $3->getType() == "BYTE";
		if (!exp1IsNumericType or !exp2IsNumericType)
		{
			output::errorMismatch(yylineno);
			exit(0);
		}

		$$= new Symbol("BOOL", "BOOL");

		string equalCmd = $2->getType() == "==" ? "eq" : "ne";
		string newRegister = codeGenerator.freshRegister();
		string cmpCommand;
		cmpCommand = newRegister +" = icmp "+ equalCmd +" i32 " + $1->getVariable() + ", " + $3->getVariable() ;
		$$->setVariable(newRegister);
		codeBuffer.emit(cmpCommand);
	}
	| LPAREN Type RPAREN Exp %prec tempp
	{
		bool isByteType = $2->getType() == "BYTE";
		bool isIntType 	= $2->getType() == "INT";
		bool isByteExp 	= $4->getType() == "BYTE";
		bool isIntExp 	= $4->getType() == "INT";

		if( (!isIntType and !isByteType) or (!isByteExp and !isIntExp)){
			output::errorMismatch(yylineno);
			exit(0);
		}
		$$ = $4;
		$$->getType() = $2->getType();
	};

%%

int main()
{
	/* -- initialize the system -- */
	int offset = scopeManager.getOffset();
	scopeManager.insertSymbol(shared_ptr<Function>(new Function("print", "FUNCTION", "NO VARIABLE ALLOCATED", offset, "VOID", {"STRING"})));
	scopeManager.insertSymbol(shared_ptr<Function>(new Function("printi","FUNCTION", "NO VARIABLE ALLOCATED", offset, "VOID", {"INT"})));
	scopeManager.insertSymbol(shared_ptr<Function>(new Function("readi", "FUNCTION", "NO VARIABLE ALLOCATED", offset, "INT", {"INT"})));

	codeBuffer.emitGlobal("declare i32 @printf(i8*, ...)");
	codeBuffer.emitGlobal("declare i32 @scanf(i8*, ...)");
	codeBuffer.emitGlobal("declare void @exit(i32)");
	codeBuffer.emitGlobal("@.int_specifier = constant [4 x i8] c\"%d\\0A\\00\"");
	codeBuffer.emitGlobal("@.int_specifier_scan = constant [3 x i8] c\"%d\\00\"");
	codeBuffer.emitGlobal("@.str_specifier = constant [4 x i8] c\"%s\\0A\\00\"");
	codeBuffer.emitGlobal("@.zero_div_string = constant [23 x i8] c\"Error division by zero\\00\""); // ""

	codeBuffer.emit("define void @print(i8*) {");
	codeBuffer.emit("%spec_ptr = getelementptr [4 x i8], [4 x i8]* @.str_specifier, i32 0, i32 0");
	codeBuffer.emit("call i32 (i8*, ...) @printf(i8* %spec_ptr, i8* %0)");
	codeBuffer.emit("ret void");
	codeBuffer.emit("}");

	codeBuffer.emit("define void @printi(i32) {");
	codeBuffer.emit("%spec_ptr = getelementptr [4 x i8], [4 x i8]* @.int_specifier, i32 0, i32 0");
	codeBuffer.emit("call i32 (i8*, ...) @printf(i8* %spec_ptr, i32 %0)");
	codeBuffer.emit("ret void");
	codeBuffer.emit("}");

	codeBuffer.emit("define i32 @readi(i32) {");
	codeBuffer.emit("%ret_val = alloca i32");
	codeBuffer.emit("%spec_ptr = getelementptr [3 x i8], [3 x i8]* @.int_specifier_scan, i32 0, i32 0");
	codeBuffer.emit("call i32 (i8*, ...) @scanf(i8* %spec_ptr, i32* %ret_val)");
	codeBuffer.emit("%val = load i32, i32* %ret_val");
	codeBuffer.emit("ret i32 %val");
	codeBuffer.emit("}");

	codeBuffer.emit("define i32 @main(){");
	// alloca 50 local variables on stack :
	codeBuffer.emit("%size = add i32 50, 0");
	codeBuffer.emit("%stack_ptr = alloca [50 x i32]");
	int parserReturnVal = yyparse();
	codeBuffer.emit("ret i32 0");
	codeBuffer.emit("}");

	if (!parserReturnVal)
	{
		scopeManager.popScope();
		codeBuffer.printGlobalBuffer();
		codeBuffer.printCodeBuffer();
	}
	return parserReturnVal;
}

void yyerror(const char *message)
{
	output::errorSyn(yylineno);
}
