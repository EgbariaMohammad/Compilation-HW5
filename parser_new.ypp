%{
    // *** includes *** //
    #include "cg.hpp"
	#include "Symbol.hpp"
	#include "ScopeManager.hpp"
    #include "hw3_output.hpp"

    // *** Declarations *** //
	ScopeManager& scopeManager = ScopeManager::getInstance();
	CodeGenerator& codeGenerator = CodeGenerator::getInstance();
	CodeBuffer& codeBuffer = CodeBuffer::instance();

    // *** Flex externals *** //
	extern int yylex();
	extern int yylineno;
	void yyerror(const char *message);
%}

%token 		VOID
%token 		INT
%token		BYTE
%token		B
%token		BOOL
%token		CONST
%token		TRUE
%token		FALSE
%token		RETURN
%nonassoc 	temp
%nonassoc 	ELSE
%nonassoc	IF
%token		WHILE
%token		BREAK
%token		CONTINUE
%token		COLON
%token		SC
%token		COMMA
%token		COMMENT
%token		ID
%token		NUM
%token		STRING
%token		LBRACE
%token		RBRACE

%left   	OR
%left		AND
%right		ASSIGN
%left 		EQUALITY
%nonassoc	NONASSOCCRELOP
%left  		ADD SUB
%left 		MUL DIV
%right		NOT
%left		LPAREN RPAREN
%nonassoc 	tempp

%%
Program : Statements;
Statements : Statement | Statements Statement;
Statement :
    LBRACE { scopeManager.pushScope(ScopeType::BLOCK); } Statements RBRACE FINISH
    | Type ID SC
    {
        // check if ID was declared in this scope previously
        if(scopeManager.findSymbolInCurrentScope($2->getName()) == true)
		{
			output::errorDef(yylineno, $2->getName());
            exit(0);
		}
        int variableOffset = scopeManager.getOffset();
		shared_ptr<Symbol> newSymbol = make_shared<Symbol>($1->getType(), $2->getName(), "NO VARIABLE", variableOffset);
		scopeManager.insertSymbol(newSymbol);

        string varOffset = codeGenerator.intToString(variableOffset);
		string varAddress = codeGenerator.freshRegister();
		string allocCode = varAddress + " = getelementptr [50 x i32], [50 x i32]* %stack_ptr, i32 0, i32 " + varOffset;
		string storeValCode = "store i32 0, i32* " + varAddress;
		codeBuffer.emit(allocCode);
		codeBuffer.emit(storeValCode);
    }
    | Type ID ASSIGN Exp SC
    {
        bool expInt = $4->getType() == "INT";
		bool expByte = $4->getType() == "BYTE";
		bool idInt = $1->getType() == "INT";
		scopeManager.printScope();
        // check if the assign is valid!
        if($1->getType() == "BYTE" and $4->getValue() > 255)
		{
			output::errorByteTooLarge(yylineno,to_string($5->getValue()));
			exit(0);
		}
		else if($4->getType() != $1->getType() and (!(expByte && idInt)))
		{ // check if the variable type doesn't match the value given, but it's not int that holds a byte!
			output::errorMismatch(yylineno);
			exit(0);
		}
		else if(scopeManager.findSymbolInCurrentScope($2->getName()) == true)
		{
			output::errorDef(yylineno, $2->getName());
            exit(0);
		}

        //here we know that assign is legal and symbol doesn't exists
        int variableOffset = scopeManager.getOffset();
		shared_ptr<Symbol> newSymbol = make_shared<Symbol>($1->getType(), $2->getName(), "NO VARIABLE", variableOffset);
		scopeManager.insertSymbol(newSymbol);
        string varOffset = codeGenerator.intToString(variableOffset);
        string newVariable1 = codeGenerator.freshRegister();
        if($4->getType() == "BOOL")
		{
			string NextLabel = codeBuffer.freshLabel();
			string newValue1 = codeGenerator.freshRegister();
			string newValue2 = codeGenerator.freshRegister();
			string newVariable2 = codeGenerator.freshRegister();
			codeBuffer.emit($4->getTrueLabel() + ":");
			codeBuffer.emit(newVariable1 + " = getelementptr [50 x i32], [50 x i32]* %stack_ptr, i32 0, i32 " + varOffset);
			codeBuffer.emit(newValue1 + " = zext i1 1 to i32");
			codeBuffer.emit("store i32 " + newValue1 + ", i32* " + newVariable1);
			codeBuffer.emit("br label %" + NextLabel);
			codeBuffer.emit($4->getFalseLabel() + ":");
			codeBuffer.emit(newVariable2 + " = getelementptr [50 x i32], [50 x i32]* %stack_ptr, i32 0, i32 " + varOffset);
			codeBuffer.emit(newValue2 + " = zext i1 0 to i32");
			codeBuffer.emit("store i32 " + newValue2 + ", i32* " + newVariable2);
			codeBuffer.emit("br label %" + NextLabel);
			codeBuffer.emit(NextLabel + ":");
		}
		else if($4->getType() == "BYTE")
		{
			codeBuffer.emit(newVariable1 + " = getelementptr [50 x i32], [50 x i32]* %stack_ptr, i32 0, i32 " + varOffset);
			string newVariable2 = codeGenerator.freshRegister();
			codeBuffer.emit(newVariable2 + " = zext i8 " + $4->getRegName() + " to i32");
			codeBuffer.emit("store i32 " + newVariable2 + ", i32* " + newVariable1);
		}
		else
		{
			string code1 = newVariable1 + " = getelementptr [50 x i32], [50 x i32]* %stack_ptr, i32 0, i32 " + varOffset;
			string code2 = "store i32 " + $4->getRegName() + ", i32* " + newVariable1;
			codeBuffer.emit(code1);
			codeBuffer.emit(code2);
		}
    }
	| ID ASSIGN Exp SC
	{
		bool exists = scopeManager.findSymbol($1->getName()) == true;
		if(!exists)
		{
			output::errorUndef(yylineno, $1->getName());
			exit(0);
		}
		shared_ptr<Symbol> symbol = scopeManager.getSymbol($1->getName());
		bool expInt = $3->getType() == "INT";
		bool expByte = $3->getType() == "BYTE";
		bool idInt = symbol->getType() == "INT";

        // check if the assign is valid!
        if(symbol->getType() == "BYTE" and $3->getValue() > 255)
		{
			string value = codeGenerator.intToString($3->getValue());
			output::errorByteTooLarge(yylineno, value);
			exit(0);
		}
		else if(symbol->getType() != $3->getType() and !(expByte && idInt))
		{
			output::errorMismatch(yylineno);
			exit(0);
		}

        int variableOffset = symbol->getOffset();
        string varOffset = codeGenerator.intToString(variableOffset);
		string newVariable1 = codeGenerator.freshRegister();
        if($3->getType() == "BOOL")
		{
			string NextLabel = codeBuffer.freshLabel();
			string newValue1 = codeGenerator.freshRegister();
			string newValue2 = codeGenerator.freshRegister();
			string newVariable2 = codeGenerator.freshRegister();
			codeBuffer.emit($4->getTrueLabel() + ":");
			codeBuffer.emit(newVariable1 + " = getelementptr [50 x i32], [50 x i32]* %stack_ptr, i32 0, i32 " + varOffset);
			codeBuffer.emit(newValue1 + " = zext i1 1 to i32");
			codeBuffer.emit("store i32 " + newValue1 + ", i32* " + newVariable1);
			codeBuffer.emit("br label %" + NextLabel);
			codeBuffer.emit($4->getFalseLabel() + ":");
			codeBuffer.emit(newVariable2 + " = getelementptr [50 x i32], [50 x i32]* %stack_ptr, i32 0, i32 " + varOffset);
			codeBuffer.emit(newValue2 + " = zext i1 0 to i32");
			codeBuffer.emit("store i32 " + newValue2 + ", i32* " + newVariable2);
			codeBuffer.emit("br label %" + NextLabel);
			codeBuffer.emit(NextLabel + ":");
		}
		else if($2->getType() == "BYTE")
		{
			codeBuffer.emit(newVariable1 + " = getelementptr [50 x i32], [50 x i32]* %stack_ptr, i32 0, i32 " + varOffset);
			string newVariable2 = codeGenerator.freshRegister();
			codeBuffer.emit(newVariable2 + " = zext i8 " + $4->getRegName() + " to i32");
			codeBuffer.emit("store i32 " + newVariable2 + ", i32* " + newVariable1);
		}
		else
		{
			string code1 = newVariable1 + " = getelementptr [50 x i32], [50 x i32]* %stack_ptr, i32 0, i32 " + varOffset;
			string code2 = "store i32 " + $4->getRegName() + ", i32* " + newVariable1;
			codeBuffer.emit(code1);
			codeBuffer.emit(code2);
		}
	}
	| Call SC {}
	| RETURN SC { codeBuffer.emit("ret i32 0"); }
	| IF LPAREN Exp { codeBuffer.emit(codeGenerator.getMostRecentTrueLabel()); } RPAREN Statement
	{
		scopeManager.pushScope(ScopeType::IF_STATEMENT);
		codeBuffer.emit("br label %" + $3->getFalseLabel());
		codeBuffer.emit($3->getFalseLabel() + ":");
		scopeManager.popScope();
	}

Call: ID LPAREN Exp RPAREN
	{

	};

Exp: ID
	{
		bool exists = scopeManager.findSymbol($1->getName()) == true;
		if(!exists)
		{
			output::errorUndef(yylineno, $1->getName());
			exit(0);
		}
		shared_ptr<Symbol> symbol = scopeManager.getSymbol($1->getName());
        string typeOfId = symbol->getType(); // TODO: check if function!
        if(typeOfId == "FUNCTION") {
            output::errorUndef(yylineno, $1->getName());
			exit(0);
        }
		string varOffset = codeGenerator.intToString(symbol->getOffset());
        string addressVariable = codeGenerator.freshRegister();
        string valueVariable = codeGenerator.freshRegister();
        codeBuffer.emit(addressVariable + " = getelementptr [50 x i32], [50 x i32]* %stack_ptr, i32 0, i32 " + varOffset);
        codeBuffer.emit(valueVariable + " = load i32, i32* " + addressVariable);
        string trueLabel = codeBuffer.freshLabel();
        string falseLabel = codeBuffer.freshLabel();
        string finalValueRegister;
        if (typeOfId == "BOOL")
		{
			string truncValueReg = codeGenerator.freshRegister();
			string truncCommandCode = truncValueReg + " = trunc i32 " + valueVariable + " to i1";
			codeBuffer.emit(truncCommandCode);
            codeBuffer.emit("br i1 " + truncValueReg + ", label %" + trueLabel + ", label %" + falseLabel);
			finalValueRegister = truncValueReg ;
			codeGenerator.setMostRecentTrueLabel(trueLabel);
		}
        else {
            finalValueRegister = valueVariable ;
        }
        $$ = new Symbol(typeOfId, $1->getName(), finalValueRegister, -1, trueLabel, falseLabel);
	}

	| Call { $$ = $1; }

	| NUM {
		string variable = codeGenerator.freshRegister();
		string code = variable + "= add i32 " + to_string($1->getValue()) + ",0";
		codeBuffer.emit(code);
		$$->setRegName(variable);
	}

	| NUM B
	{
		int value = $1->getValue();
		if (value > 255)
		{
			output::errorByteTooLarge(yylineno, std::to_string(value));
			exit(0);
		}
		string stringValue = std::to_string(value);
		$$ = new Symbol("BYTE", std::to_string($1->getValue()));
		string variable = codeGenerator.freshRegister();
		string code = variable + "= add i32 " + std::to_string($1->getValue()) + ",0";
		codeBuffer.emit(code);
		$$->setRegName(variable);
	}

	| STRING {
		string text = $1->getStringValue();
		text = text.substr(1, text.size() - 2); // removing the " from start and end
		string typeOfString = "[" + std::to_string(text.size() + 1) + " x i8]";
		string nameOfString = "@.STRING_" + std::to_string(codeGenerator.getStringCounter()) + "_str";
		codeBuffer.emitGlobal(nameOfString + " = internal constant" + typeOfString + " c\"" + text + "\\00\"");
		codeGenerator.increaseStringCounter();
		string var = codeGenerator.freshRegister();
		string command = var + " = getelementptr " + typeOfString + ", " + typeOfString + "* " + nameOfString + ", i32 0, i32 0";
		codeBuffer.emit(command);
		$$ = new Symbol("STRING", $1->getType());
		$$->setRegName(var);
	}

	| TRUE {
		$$ = $1;
		string var = codeGenerator.freshRegister();
		string code = var + " = add i1 1,0";
		codeBuffer.emit(code);
		$$->setRegName(var);
	}

	| FALSE {
		$$ = $1;
		string var = codeGenerator.freshRegister();
		string s = var + " = add i1 0,0";
		codeBuffer.emit(s);
		$$->setRegName(var);
	}

Type: INT  { $$ = new Symbol("INT", "INT");   }
	| BYTE { $$ = new Symbol("BYTE", "BYTE"); }
	| BOOL { $$ = new Symbol("BOOL", "BOOL"); };

FINISH:
{
    scopeManager.popScope();
};

%%

int main()
{
	/* -- initialize the system -- */
	int offset = scopeManager.getOffset();
	scopeManager.insertSymbol(shared_ptr<Function>(new Function("print", offset, "VOID", {"STRING"})));
	scopeManager.insertSymbol(shared_ptr<Function>(new Function("printi", offset, "VOID", {"INT"})));
	scopeManager.insertSymbol(shared_ptr<Function>(new Function("readi", offset, "INT", {"INT"})));

	codeBuffer.emitGlobal("declare i32 @printf(i8*, ...)");
	codeBuffer.emitGlobal("declare i32 @scanf(i8*, ...)");
	codeBuffer.emitGlobal("declare void @exit(i32)");
	codeBuffer.emitGlobal("@.int_specifier = constant [4 x i8] c\"%d\\0A\\00\"");
	codeBuffer.emitGlobal("@.int_specifier_scan = constant [3 x i8] c\"%d\\00\"");
	codeBuffer.emitGlobal("@.str_specifier = constant [4 x i8] c\"%s\\0A\\00\"");
	codeBuffer.emitGlobal("@.zero_div_string = constant [23 x i8] c\"Error division by zero\\00\""); // ""

	codeBuffer.emit("define void @print(i8*) {");
	codeBuffer.emit("%spec_ptr = getelementptr [4 x i8], [4 x i8]* @.str_specifier, i32 0, i32 0");
	codeBuffer.emit("call i32 (i8*, ...) @printf(i8* %spec_ptr, i8* %0)");
	codeBuffer.emit("ret void");
	codeBuffer.emit("}");

	codeBuffer.emit("define void @printi(i32) {");
	codeBuffer.emit("%spec_ptr = getelementptr [4 x i8], [4 x i8]* @.int_specifier, i32 0, i32 0");
	codeBuffer.emit("call i32 (i8*, ...) @printf(i8* %spec_ptr, i32 %0)");
	codeBuffer.emit("ret void");
	codeBuffer.emit("}");

	codeBuffer.emit("define i32 @readi(i32) {");
	codeBuffer.emit("%ret_val = alloca i32");
	codeBuffer.emit("%spec_ptr = getelementptr [3 x i8], [3 x i8]* @.int_specifier_scan, i32 0, i32 0");
	codeBuffer.emit("call i32 (i8*, ...) @scanf(i8* %spec_ptr, i32* %ret_val)");
	codeBuffer.emit("%val = load i32, i32* %ret_val");
	codeBuffer.emit("ret i32 %val");
	codeBuffer.emit("}");

	codeBuffer.emit("define i32 @main(){");
	// alloca 50 local variables on stack :
	codeBuffer.emit("%size = add i32 50, 0");
	codeBuffer.emit("%stack_ptr = alloca [50 x i32]");
	int parserReturnVal = yyparse();
	codeBuffer.emit("ret i32 0");
	codeBuffer.emit("}");

	if (!parserReturnVal)
	{
		scopeManager.popScope();
		codeBuffer.printGlobalBuffer();
		codeBuffer.printCodeBuffer();
	}
	return parserReturnVal;
}

void yyerror(const char *message)
{
	output::errorSyn(yylineno);
}
